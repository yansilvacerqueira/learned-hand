# Codebase Findings and Issues

This document outlines all security issues, performance problems, bugs, and code quality issues found in the codebase, along with their impact and proposed fixes.

---

## 游댮 CRITICAL SECURITY ISSUES

### 1. SQL Injection Vulnerability in Search Endpoint

**Location:** `backend/app/routes/search.py:13`

**Issue:**

```python
query = text(f"SELECT id, filename, content FROM documents WHERE content ILIKE '%{q}%'")
```

The search query uses f-string interpolation directly, making it vulnerable to SQL injection attacks. An attacker could inject malicious SQL code through the `q` parameter.

**Impact:**

- **CRITICAL** - Complete database compromise possible
- Data exfiltration, data deletion, or privilege escalation
- Could lead to full system compromise

**Fix:**
Use parameterized queries with SQLAlchemy's ORM or proper parameter binding:

```python
from sqlalchemy import select, func
query = select(Document.id, Document.filename, Document.content).where(
  Document.content.ilike(f"%{q}%")
)
```

---

### 2. Hardcoded Secret Key

**Location:** `backend/app/config.py:9`

**Issue:**

```python
SECRET_KEY: str = "my-super-secret-key-do-not-share"
```

The secret key is hardcoded in the source code, making it visible in version control and easily accessible.

**Impact:**

- **HIGH** - If JWT or session tokens are used, they can be forged
- Security tokens can be generated by attackers
- Session hijacking possible

**Fix:**
Use environment variable with no default (fail fast if missing):

```python
SECRET_KEY: str = os.getenv("SECRET_KEY")
if not SECRET_KEY:
    raise ValueError("SECRET_KEY environment variable must be set")
```

---

### 3. CORS Allows All Origins

**Location:** `backend/app/main.py:20`

**Issue:**

```python
allow_origins=["*"]
```

CORS is configured to allow requests from any origin, which is a security risk in production.

**Impact:**

- **MEDIUM-HIGH** - Cross-origin attacks possible
- Any website can make requests to the API
- CSRF attacks easier to execute

**Fix:**
Restrict to specific origins:

```python
allow_origins=[
    "http://localhost:5173",
    "https://yourdomain.com"
]
```

---

### 4. No File Type Validation

**Location:** `backend/app/routes/documents.py:18-27`

**Issue:**
The upload endpoint accepts any file type without validation. It only checks the file extension implicitly through PDF processing, but doesn't validate MIME type or file signature.

**Impact:**

- **HIGH** - Malicious files can be uploaded
- Potential for malware distribution
- Server resource exhaustion
- Could execute code if files are processed unsafely

**Fix:**
Add comprehensive file validation:

- Check MIME type (`file.content_type`)
- Validate file signature (magic bytes)
- Enforce file extension
- Limit file size

---

### 5. No File Size Limits

**Location:** `backend/app/routes/documents.py:18-27`

**Issue:**
No maximum file size is enforced, allowing unlimited uploads.

**Impact:**

- **MEDIUM** - Denial of Service (DoS) attacks
- Disk space exhaustion
- Memory exhaustion during processing
- Server crashes

**Fix:**
Add file size validation:

```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
if file_size > MAX_FILE_SIZE:
    raise HTTPException(status_code=413, detail="File too large")
```

---

### 6. Path Traversal Vulnerability

**Location:** `backend/app/routes/documents.py:20`

**Issue:**

```python
file_path = os.path.join(settings.UPLOAD_DIR, file.filename)
```

The filename is used directly without sanitization, allowing path traversal attacks (e.g., `../../../etc/passwd`).

**Impact:**

- **HIGH** - Arbitrary file write/read
- Could overwrite system files
- Data exfiltration from server

**Fix:**
Sanitize filename:

```python
import os
from pathlib import Path

filename = os.path.basename(file.filename)  # Remove path components
# Further sanitize: remove special characters, validate format
safe_filename = "".join(c for c in filename if c.isalnum() or c in "._-")
file_path = os.path.join(settings.UPLOAD_DIR, safe_filename)
```

---

### 7. No Authentication/Authorization

**Location:** All routes in `backend/app/routes/`

**Issue:**
All endpoints are publicly accessible without any authentication or authorization checks.

**Impact:**

- **CRITICAL** - Anyone can upload, delete, or access documents
- No access control
- Data breach risk
- Unauthorized data modification

**Fix:**
Implement authentication middleware and protect routes:

- Add JWT-based authentication
- Implement role-based access control (RBAC)
- Protect sensitive endpoints (DELETE, POST)

---

### 8. Weak Database Password in Default Config

**Location:** `backend/app/config.py:7`

**Issue:**

```python
"postgresql+asyncpg://postgres:supersecretpassword123@localhost:5432/docproc"
```

Default database password is weak and visible in code.

**Impact:**

- **MEDIUM** - If code is exposed, database is compromised
- Default credentials are guessable

**Fix:**
Remove default password, require environment variable:

```python
DATABASE_URL: str = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("DATABASE_URL environment variable must be set")
```

---

## 丘멆잺 PERFORMANCE ISSUES

### 9. N+1 Query Problem in Document List

**Location:** `backend/app/routes/documents.py:50-72`

**Issue:**

```python
for doc in documents:
    status_result = await db.execute(
        select(ProcessingStatus).where(ProcessingStatus.document_id == doc.id)
    )
```

For each document, a separate query is executed to fetch its processing status, resulting in N+1 queries.

**Impact:**

- **MEDIUM** - Poor performance with many documents
- Database load increases linearly with document count
- Slow response times

**Fix:**
Use JOIN or eager loading:

```python
from sqlalchemy.orm import selectinload

result = await db.execute(
    select(Document).options(selectinload(Document.processing_status))
)
documents = result.scalars().all()
```

---

### 10. No Pagination for Document List

**Location:** `backend/app/routes/documents.py:50-52`

**Issue:**

```python
result = await db.execute(select(Document))
documents = result.scalars().all()
```

All documents are loaded into memory at once without pagination.

**Impact:**

- **MEDIUM** - Memory exhaustion with large datasets
- Slow response times
- Poor user experience

**Fix:**
Implement pagination:

```python
from fastapi import Query

@router.get("/documents")
async def list_documents(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=1000),
    db: AsyncSession = Depends(get_db)
):
    result = await db.execute(
        select(Document).offset(skip).limit(limit)
    )
```

---

### 11. No Database Indexes for Search

**Location:** `backend/app/models.py:8-16`

**Issue:**
The `content` column used for search has no index, making searches slow on large datasets.

**Impact:**

- **MEDIUM** - Slow search queries
- Full table scans on every search
- Performance degrades with data growth

**Fix:**
Add full-text search index:

```python
from sqlalchemy import Index

class Document(Base):
    # ... existing fields ...

    __table_args__ = (
        Index('idx_content_gin', 'content', postgresql_using='gin', postgresql_ops={'content': 'gin_trgm_ops'}),
    )
```

Or use PostgreSQL full-text search with `tsvector`.

---

### 12. Synchronous File I/O in Async Context

**Location:** `backend/app/routes/documents.py:22-24`

**Issue:**

```python
with open(file_path, "wb") as f:
    content = await file.read()
    f.write(content)
```

Synchronous file I/O blocks the event loop in an async function.

**Impact:**

- **LOW-MEDIUM** - Reduced concurrency
- Other requests blocked during file write
- Poor scalability

**Fix:**
Use async file I/O:

```python
import aiofiles

async with aiofiles.open(file_path, "wb") as f:
    content = await file.read()
    await f.write(content)
```

---

### 13. No Caching for Search Results

**Location:** `backend/app/routes/search.py:11-29`

**Issue:**
Every search query hits the database, even for repeated queries.

**Impact:**

- **LOW-MEDIUM** - Unnecessary database load
- Slower response for repeated queries

**Fix:**
Implement caching (Redis or in-memory cache):

```python
from functools import lru_cache
# Or use Redis for distributed caching
```

---

## 游냍 BUGS AND CODE QUALITY ISSUES

### 14. Missing Error Handling in PDF Processing

**Location:** `backend/app/services/pdf_processor.py:4-11`

**Issue:**

```python
async def extract_text_from_pdf(file_path: str) -> tuple[str, int]:
    doc = fitz.open(file_path)
    # No error handling for corrupted/invalid PDFs
```

No error handling for corrupted PDFs, invalid files, or processing failures.

**Impact:**

- **MEDIUM** - Application crashes on invalid PDFs
- Poor user experience
- Unhandled exceptions

**Fix:**
Add comprehensive error handling:

```python
async def extract_text_from_pdf(file_path: str) -> tuple[str, int]:
    try:
        doc = fitz.open(file_path)
        # ... processing ...
    except Exception as e:
        raise ValueError(f"Failed to process PDF: {str(e)}")
    finally:
        if 'doc' in locals():
            doc.close()
```

---

### 15. Files Not Deleted After Processing

**Location:** `backend/app/routes/documents.py:18-47`

**Issue:**
Uploaded files are saved to disk but never deleted, causing disk space to fill up over time.

**Impact:**

- **MEDIUM** - Disk space exhaustion
- Storage costs increase
- Server performance degradation

**Fix:**
Delete files after processing or implement cleanup job:

```python
try:
    # ... process file ...
finally:
    if os.path.exists(file_path):
        os.remove(file_path)
```

Or store files in object storage (S3) and delete after processing.

---

### 16. Incorrect Delete Method Usage and Race Condition

**Location:** `backend/app/routes/documents.py:112, 114`

**Issue:**

```python
if status:
    await db.delete(status)  # Incorrect - db.delete() doesn't exist in SQLAlchemy

await db.delete(document)  # Incorrect
await db.commit()
```

The code uses `await db.delete()` which is not a valid SQLAlchemy async method. In SQLAlchemy 2.0 async, you should use `session.delete(obj)` (synchronous method) followed by `await session.commit()`. Also, there's a potential race condition since the document and status are loaded in separate queries.

**Impact:**

- **MEDIUM** - Code will fail at runtime (AttributeError: 'AsyncSession' object has no attribute 'delete')
- Orphaned records if only one deletion succeeds
- Database inconsistencies
- Race condition if document is modified between queries

**Fix:**
Use proper SQLAlchemy async deletion:

```python
# Load both in a single query to avoid race conditions
result = await db.execute(
    select(Document, ProcessingStatus)
    .outerjoin(ProcessingStatus, Document.id == ProcessingStatus.document_id)
    .where(Document.id == document_id)
)
row = result.first()

if not row:
    raise HTTPException(status_code=404, detail="Document not found")

document, status = row
if status:
    db.delete(status)  # Synchronous method, no await
db.delete(document)  # Synchronous method, no await
await db.commit()  # Async commit
```

---

### 17. Deprecated datetime.utcnow()

**Location:** `backend/app/routes/documents.py:42` and `backend/app/models.py:16`

**Issue:**

```python
created_at = Column(DateTime, default=datetime.utcnow)
processed_at = Column(DateTime, nullable=True)
# Used as: datetime.utcnow()
```

`datetime.utcnow()` is deprecated in Python 3.12+.

**Impact:**

- **LOW** - Deprecation warnings
- Future compatibility issues

**Fix:**
Use timezone-aware datetime:

```python
from datetime import datetime, timezone

created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))
# Or in code:
processed_at = datetime.now(timezone.utc)
```

---

### 18. No Input Validation on document_id

**Location:** `backend/app/routes/documents.py:75, 100`

**Issue:**
No validation that `document_id` is positive or within reasonable bounds.

**Impact:**

- **LOW** - Unnecessary database queries for invalid IDs
- Potential for negative ID injection

**Fix:**
Add validation:

```python
from pydantic import PositiveInt

@router.get("/documents/{document_id}")
async def get_document(document_id: PositiveInt, ...):
```

---

### 19. Poor Error Handling in Frontend API Calls

**Location:** `frontend/src/api.js` and components

**Issue:**
API calls don't check response status or provide meaningful error messages:

```javascript
const response = await fetch(`${API_BASE}/documents`);
return response.json(); // No status check
```

**Impact:**

- **MEDIUM** - Poor user experience
- Errors not properly communicated
- Application may crash on API errors

**Fix:**
Add proper error handling:

```javascript
export async function getDocuments() {
  const response = await fetch(`${API_BASE}/documents`);
  if (!response.ok) {
    throw new Error(`Failed to fetch documents: ${response.statusText}`);
  }
  return response.json();
}
```

---

### 20. window.location.reload() in Upload Form

**Location:** `frontend/src/components/UploadForm.jsx:19`

**Issue:**

```javascript
window.location.reload();
```

Full page reload after upload is poor UX and loses application state.

**Impact:**

- **LOW** - Poor user experience
- Loss of scroll position
- Unnecessary full page reload

**Fix:**
Use state management to refresh document list:

```javascript
// Pass refresh callback or use context/state management
onUploadSuccess?.(); // Callback to refresh list
```

---

### 21. Duplicate formatFileSize Function

**Location:** `frontend/src/components/DocumentList.jsx:60-65` and `DocumentDetail.jsx:77-82`

**Issue:**
The `formatFileSize` function is duplicated in two components.

**Impact:**

- **LOW** - Code duplication
- Maintenance burden
- Inconsistency risk

**Fix:**
Extract to shared utility:

```javascript
// utils/formatters.js
export function formatFileSize(bytes) { ... }
```

---

### 22. Missing Error Handling for PDF Extraction Failures

**Location:** `backend/app/routes/documents.py:27`

**Issue:**
If PDF extraction fails, the error is not caught, and the file is still saved to disk and database entry created.

**Impact:**

- **MEDIUM** - Incomplete document records
- Database inconsistencies
- Poor error reporting

**Fix:**
Add try-catch and rollback on failure:

```python
try:
    text_content, page_count = await extract_text_from_pdf(file_path)
except Exception as e:
    os.remove(file_path)  # Clean up
    raise HTTPException(status_code=400, detail=f"Failed to process PDF: {str(e)}")
```

---

### 23. No Logging

**Location:** Throughout backend code

**Issue:**
No logging for important events (uploads, deletions, errors).

**Impact:**

- **MEDIUM** - Difficult to debug issues
- No audit trail
- Security incidents hard to track

**Fix:**
Add structured logging:

```python
import logging
logger = logging.getLogger(__name__)

logger.info(f"Document uploaded: {document.id}")
logger.error(f"PDF processing failed: {str(e)}")
```

---

### 24. Missing File Type Validation in Frontend

**Location:** `frontend/src/components/UploadForm.jsx:32-36`

**Issue:**
File input doesn't restrict file types or validate before upload.

**Impact:**

- **LOW** - Users can select wrong file types
- Wasted bandwidth on invalid uploads

**Fix:**
Add file type validation:

```javascript
<input
  type="file"
  accept=".pdf,application/pdf"
  onChange={(e) => {
    const file = e.target.files[0];
    if (file && file.type !== "application/pdf") {
      setError("Please select a PDF file");
      return;
    }
    setFile(file);
  }}
/>
```

---

## 游늶 SUMMARY

### Security Issues: 8

- 游댮 Critical: 3 (SQL Injection, No Auth, Path Traversal)
- 游 High: 3 (File Validation, File Size, Hardcoded Secrets)
- 游리 Medium: 2 (CORS, Weak Default Password)

### Performance Issues: 5

- 游리 Medium: 4 (N+1 Queries, No Pagination, No Indexes, Sync I/O)
- 游릭 Low: 1 (No Caching)

### Bugs and Code Quality: 11

- 游리 Medium: 4 (Error Handling, File Cleanup, Race Conditions, Logging)
- 游릭 Low: 7 (Deprecated APIs, Code Duplication, UX Issues)

---

## 游늶 TODO: Authentication System with RBAC

### Overview

Implement a authentication and authorization system using Role-Based Access Control (RBAC) to secure all API endpoints.

### Requirements

**Authentication:**

- JWT-based token authentication
- User registration and login endpoints
- Password hashing (bcrypt/argon2)
- Token refresh mechanism
- Session management

**Authorization (RBAC):**

- Role-based permissions (Admin, User, Viewer)
- Protected routes with role checks
- Permission middleware for endpoints
- User roles stored in database

**Implementation:**

- User model with roles
- Authentication middleware
- Protected route decorators
- Frontend login/register pages
- Token storage and refresh logic
